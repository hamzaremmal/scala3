\documentclass{report}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, text width=6cm, draw=black]
\tikzstyle{arrow} = [thick,->,>=stealth]

\begin{document}

\title{Tastydoc: a cocumentation tool for dotty using Tasty files}
\author{Bryan Abate
\\\\\small{Supervised by Aleksander Boruch-Gruszecki}}

\maketitle

\begin{abstract}
The current documentation tool (dottydoc) relies on compiler internals and low level code. The tool introduced here aims to build a program not dependant on compiler internals but instead use Tasty files which are output when a Scala program is compiled.

It also aims at providing a tool with less bugs, more features and which is more easily maintenable.

For flexibility the output is in Markdown instead of the commonly used HTML.
\end{abstract}

\tableofcontents

\chapter{Introduction}
In dotty the documentation generation tool is called \texttt{dotty-doc}. However the tool is flawed in many ways, these flaws include:
\begin{itemize}
    \item Reliance on compiler internals
    \item Low level and unecessarily complex code which make it hard to maintain
    \item Not maintened and not documented
    \item Not flexible in its output, it outputs HTML/css in a hard to modify way
    \item Malformed type output such as \texttt{[32m"getOffset"[0m}
    \item Classes often show to be extending Object instead of their superclass. Example: \url{https://dotty.epfl.ch/api/scala/Conversion.HTML}
\begin{lstlisting}[language=scala]
abstract class Conversion [ -T, +U ] extends Object with Function1
\end{lstlisting}
    \item Annotations which sould not be display, sometimes are. Example:
    \item Lacks some features, especially:
    \begin{itemize}
        \item No known subclasses
        \item 
    \end{itemize}
\end{itemize}

The tool introduced here aims to address all these issues while providing with a code easy to maintain and easy to adapt to every need.

One major difference with currrent documentation tools is that the output is in Markdown instead of HTML, this has some pros and cons which will be discussed below.

Althought dotty-doc has some problems, the current tool will draw inspiration for some of its architecture which will allow for its parsing code for user documentation (modified to handle this structure and output Markdown) to be reused.

The report will follow the structure described in this introduction and will conclude with problems of the current implementation and further work.

\chapter{Features}

\chapter{Output format}
Before describing the output, we list the reasons, pros and cons of using a Markdown output.

\section{Reasoning behind Markdown}

The major reason to use Markdown instead of HTML is to think of the documentation tool as a pipeline which would look like this:

\begin{center}
    \begin{tikzpicture}[node distance=2cm]
        \node (write) [process] {User writes code and documentation};
        \node (compile) [process, below of=write] {Compiler produces Tasty files};
        \node (tool) [process, below of=compile] {Tastydoc consumes Tasty files and produces Markdown};
        \node (user) [process, below of=tool] {User edits Markdown files as he wishes, Markdown being human friendly};
        \node (HTML) [process, below of=user] {Markdown files are consumed and transformed to any HTML/css combination};
    
        \draw [arrow] (write) -- (compile);
        \draw [arrow] (compile) -- (tool);
        \draw [arrow] (tool) -- (user);
        \draw [arrow] (user) -- (HTML);
    \end{tikzpicture}
\end{center}

With such a pipeline we do not limit the user to use a specific output for the documentation, he can easily remove, add parts, etc. manually and then use an HTML format of his choosing as Markdown only specify the structure not how it should be displayed.

\section{Pros and Cons}
\label{sec:proscons}
Using Markdown as an intermediate output format comes with some pros and cons comparing to an HTML output:
\begin{itemize}
    \item \textbf{Pros:}
    \begin{itemize}
        \item Human readable and editable, meaning part of the documentation can be written manually
        \item Easy to infer the format of the output to extend it manually
        \item Live preview and editing
        \item Only define the structure of the output not how to display it
        \item Easily pipelined to another format (HTML, reStructuredText, etc.)
    \end{itemize}
    \item \textbf{Cons:}
    \begin{itemize}
        \item No Scala (or Java) library available to output markdown with escaping
        \item Markdown fenced code block cannot contain links which forces us to use html code block, hence loose syntax highlight in Markdown and not output "pure" Markdown.
        \item Markdown does not have "division" like \texttt{<div>} in HTML to better structure the output
    \end{itemize}
\end{itemize}

\section{Output structure}
In the following section, we describe how the markdown output is structured.

\subsection{class, object and trait}
Have their own \texttt{.md} file.

\begin{enumerate}
    \item Name (header 1)
    \item Companion object (header 2)
    \item Signature (HTML pre + code)
    \item User documentation
    \item Annotations (header 2)
    \item Known subclasses (header 2)
    \item Constructors (header 2)
    \begin{enumerate}
        \item Name + paremeters (HTML pre + code)
        \item User documentation
    \end{enumerate}
    \item Members (header 2) (In order: Abstract Type Members, Concrete Type Members, Abstract Value Members, Concrete Value Members)
    \begin{enumerate}
        \item Follows structure described in \autoref{sec:signatureSec}
    \end{enumerate}
\end{enumerate}

\subsection{package}
Has its own \texttt{.md} file.

\begin{enumerate}
    \item Name (header 1)
    \item Members (header 2)
    \begin{enumerate}
        \item Follows structure described in \autoref{sec:signatureSec} and \autoref{sec:packageSignatureSec}
    \end{enumerate}
\end{enumerate}

\subsection{type alias, class (simplified format), def, val and var}
No \texttt{.md} file.

\label{sec:signatureSec}
\begin{enumerate}
    \item Name (header 3)
    \item Annotations + signature (HTML pre + code)
    \item User documentation
\end{enumerate}

\subsection{package (simplified format)}
No \texttt{.md} file.

\label{sec:packageSignatureSec}
\begin{enumerate}
    \item name + link (HTML pre + code)
\end{enumerate}

\chapter{Architecture}

\section{General architecture}
\subsection{TastyExtractor}
File: \texttt{dotty/tastydoc/TastyExtractor.scala}

A trait containing useful methods for extracting information from the reflect API. Methods are:
\begin{itemize}
    \item \texttt{extractPath} extract the extractPath
    \item \texttt{extractModifiers} extract all the useful modifiers, including scope modifiers
    \item \texttt{extractComments} extract user documentation, more speficially a function requiring a map of packages needed for parsing
    \item \texttt{extractClassMembers} extract the members of a class, including the inherited ones
    \item \texttt{extractParents} extract the parents of a class, object or trait
    \item \texttt{extractKind} extract information (is it an object? a trait? a class? a case?) on a \texttt{reflect.ClassDef}
    \item \texttt{extractCompanion} extract the companion object or class if it exists
    \item \texttt{extractAnnotations} extract the annotations
    \item \texttt{extractPackageNameAndPath} extract the name and the path from a \texttt{pid}
\end{itemize}

\subsection{References}
File: \texttt{dotty/tastydoc/references.scala}

Object containing case classes. References are classes containing information about a specific type to be able to link to it later on. Inspired from Dottydoc.

\subsection{TastyTypeConverter}
File: \texttt{dotty/tastydoc/TastyTypeConverter.scala}

Trait containing methods for converting from Reflect types to References.

\subsection{Representation}
File: \texttt{dotty/tastydoc/representations.scala}

Implements both \texttt{TastyExtractor} and \texttt{TastyTypeConverter}

A Representation contains all the information of a specific entity. The logic is as follows: different trait such as \texttt{Modifiers} or \texttt{Members} and classes which implement those trait. This logic is inspired by dotty-doc.

A Representation take a reflect type such as \texttt{reflect.ClassDef} and extract every information from it using mostly \texttt{TastyExtractor} functions.

Representation can then be easily used for printing, their content is self explanatory and no knowledge of Tasty is required to use them as the implementation is not exposed from the outside.

We give below the existing Representation, a quick description and their signature (without parameters).
\begin{itemize}
    \item \texttt{PackageRepresentation} For packages
\begin{lstlisting}[language=scala]
class PackageRepresentation(...)
extends Representation with Members
\end{lstlisting}
    \item \texttt{ImportRepresentation} For import, never used in the tool
\begin{lstlisting}[language=scala]
class ImportRepresentation(...)
extends Representation
\end{lstlisting}
    \item \texttt{ClassRepresentation} For class, object and trait, including case class and case object.
\begin{lstlisting}[language=scala]
class ClassRepresentation(...)
extends Representation with Members
with Parents with Modifiers with Companion
with Constructors with TypeParams
\end{lstlisting}
    \item \texttt{DefRepresentation} For definitions
\begin{lstlisting}[language=scala]
class DefRepresentation(...)
extends Representation with Modifiers
with TypeParams with MultipleParamList
with ReturnValue
\end{lstlisting}
    \item \texttt{ValRepresentation} For val and var
\begin{lstlisting}[language=scala]
class ValRepresentation(...)
extends Representation with Modifiers
with ReturnValue
\end{lstlisting}
    \item \texttt{TypeRepresentation} For type alias
\begin{lstlisting}[language=scala]
class TypeRepresentation(...)
extends Representation with Modifiers
with TypeParams 
\end{lstlisting}
    \item \texttt{EmulatedPackageRepresentation} This Representation is a trick for regrouping every PackageRepresentation of a same package under the same Representation. Indeed the way Tasty works is that for each class or trait it will have a Tasty file and the top of \texttt{reflect.Tree} is a \texttt{reflect.PackageClause}, hence when converting multiple classes of the same package, there will be mutiple \texttt{PackageRepresentation} of the same package. In the point of view of usability, this is not the best and this Representation is here to counter this problem. When using an \texttt{EmulatedPackageRepresentation}, for the user it looks like he is using a \texttt{PackageRepresentation}.
\end{itemize}

\subsection{DocPrinter}
File: \texttt{dotty/tastydoc/DocPrinter.scala}

Object with methods for formatting Representations and References and writing them to files. Basically handle all the formatting and printing logic of the tool.

\subsection{mdscala}
File: \texttt{dotty/tastydoc/mdscala.scala}

\subsection{TastyDocConsumer}
File: \texttt{dotty/tastydoc/TastyDocConsumer.scala}

Extends TastyConsumer and consume Tasty Files.

\subsection{Main}
File: \texttt{dotty/tastydoc/Main.scala}

Manages the workflow.

\subsection{mdscala}
File: \texttt{dotty/tastydoc/mdscala.scala}

Object with methods for outputing markdown (do not handle escaping).

\subsection{User documentation parsing}
See \autoref{sec:dotty-docParsing}

\section{Workflow}


\section{Formatting and writing to files}

\section{Use of dotty-doc for parsing}
\label{sec:dotty-docParsing}

\chapter{Problems encountered and further work}
\section{Problems encountered}
Here is a listing of a few problems encountered:
\begin{itemize}
    \item All the cons listed in \autoref{sec:proscons}
    \item Multi level list are not parsed correctly when ordered and unordered list are combined, they are parsed as 2 separate list. This is a problem in Flexmark
    \item If a type (class or type alias) inside a class has the same name as a def/val/var in the same class, for linking to them directly (anchor basically), there is no way to do it in markdown (there is no id, except for title). To counter this problem we list types before values so that it will always jump to the first one
\end{itemize}

\section{Further work}
Further work would include:
\begin{itemize}
    \item Make a library for outputing markdown with escaping. For example, right now, if a method is named \texttt{\#} it will cause a problem
    \item Handle correctly Type Lambdas, right now they are handeled as constant reference
\end{itemize}

\chapter{Conclusion}

\end{document}