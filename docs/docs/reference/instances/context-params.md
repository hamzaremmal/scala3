---
layout: doc-page
title: "Inferable Parameters and Arguments"
---

Functional programming tends to express most dependencies as simple functions parameterization.
This is clean and powerful, but it sometimes leads to functions that take many parameters and
call trees where the same value is passed over and over again in long call chains to many
functions. Inferable parameters can help here since they enable the compiler to synthesize
repetitive arguments instead of the programmer having to write them explicitly.

For example, given the [instance definitions](./instance-definitions.md) defined previously,
a maximum function that works for any arguments for which an ordering exists can be defined as follows:
```
def max[T](x: T, y: T) given (ord: Ord[T]): T =
  if (ord.compare(x, y) < 1) y else x
```
Here, `ord` is an _inferable parameter_. Inferable parameters are introduced with a `given` clause. Here is an example application of `max`:
```
max(2, 3) given IntOrd
```
The `given IntOrd` part provides the `IntOrd` instance as an argument for the `ord` parameter. But the point of inferable parameters is that this argument can also be left out (and usually is):
```
max(2, 3)
```
This is equally valid, and is completed by the compiler to the previous application.

## Anonymous Inferred Parameters

In many situations, the name of an inferable parameter of a method need not be
mentioned explicitly at all, since it is only used in synthesized arguments for
other inferable parameters. In that case one can avoid defining a parameter name
and just provide its type. Example:
```
def maximum[T](xs: List[T]) given Ord[T]: T =
  xs.reduceLeft(max)
```
`maximum` takes an inferable parameter of type `Ord` only to pass it on as an
inferred argument to `max`. The name of the parameter is left out.

Generally, inferable parameters may be given either as a parameter list `(p_1: T_1, ..., p_n: T_n)`
or as a sequence of types, separated by commas. To distinguish the two, a leading
`(` always indicates a parameter list.

## Synthesizing Complex Inferred Arguments

Here are two other methods that have an inferable parameter of type `Ord[T]`:
```scala
def descending[T] given (asc: Ord[T]): Ord[T] = new Ord[T] {
  def compare(x: T, y: T) = asc.compare(y, x)
}

def minimum[T](xs: List[T]) given Ord[T] =
  maximum(xs) given descending
```
The `minimum` method's right hand side passes `descending` as an explicit argument to `maximum(xs)`.
But usually, explicit arguments for inferable parameters are be left out. For instance,
given `xs: List[Int]`, the following calls are all possible (and they all normalize to the last one:)
```scala
minimum(xs)
maximum(xs) given descending
maximum(xs) given (descending given ListOrd)
maximum(xs) given (descending given (ListOrd given InOrd))
```
In summary, the argument passed in the definition of minimum is constructed
from the `descending` function applied to the argument `ListOrd`, which is
in turn applied to the argument `IntOrd`.

## Mixing Inferable And Normal Parameters

Inferable parameters can be freely mixed with normal parameter lists.
An inferable parameter may be followed by a normal parameter and _vice versa_.
There can be several inferable parameter lists in a definition. Example:
```scala
def f given (u: Universe) (x: u.T) given Context = ...

inferred global for Universe { type T = String ... }
inferred ctx for Context { ... }
```
Then the following calls are all valid (and normalize to the last one)
```scala
f("abc")
(f given global)("abc")
f("abc") given ctx
(f given global)("abc") given ctx
```

## Summmoning an Inferred Instance

A method `infer` in `Predef` creates an instance value for a given type. For example,
the instance value for `Ord[List[Int]]` is generated by
```
infer[Ord[List[Int]]]
```
The `infer` method is simply defined as the identity function with an inferable parameter.
```scala
def infer[T] given (x: T) = x
```

## Syntax

Here is the new syntax of parameters and arguments seen as a delta from the [standard context free syntax of Scala 3](http://dotty.epfl.ch/docs/internals/syntax.html).
```
ClsParamClause    ::=  ...
                    |  ‘given’ (‘(’ [ClsParams] ‘)’ | ContextTypes)
DefParamClause    ::=  ...
                    |  InferParamClause
InferParamClause  ::=  ‘given’ (‘(’ DefParams ‘)’ | ContextTypes)
ContextTypes      ::=  RefinedType {‘,’ RefinedType}

InfixExpr         ::=  ...
                    |  InfixExpr ‘given’ (InfixExpr | ParArgumentExprs)
```
