object tasty {

// ------ Names --------------------------------

  trait Name
  trait PossiblySignedName

  enum TermName extends Name with PossiblySignedName {
    case Simple(str: String)
    case Qualified(prefix: TermName, selector: String)              // s"$prefix.$name"
    case Unique(underlying: TermName, separator: String, idx: Int)  // s"$underlying$separator$idx"
    case DefaultGetter(methodName: TermName, idx: String)           // s"$methodName${"$default$"}${idx+1}"
    case Variant(underlying: TermName, covariant: Boolean)          // s"${if (covariant) "+" else "-"}$underlying"
    case SuperAccessor(underlying: TermName)                        // s"${"super$"}$underlying"
    case protectedAccessor(underlying: TermName)                    // s"${"protectded$"}$underlying"
    case protectecSetter(underlying: TermName)                      // s"${"protectded$set"}$underlying"
    case ObjectClass(underlying: TermName)                          // s"$underlying${"$"}"

    case Expanded(prefix: TermName, selector: String)               // s"$prefix${"$$"}$name"  , used only for symbols coming from Scala 2
    case ExpandedPrefix(prefix: TermName, selector: String)         // s"$prefix${"$"}$name"   , used only for symbols coming from Scala 2
  }

  case class SignedName(name: TermName, resultSig: TypeName, paramSigs: List[TypeName]) extends PossiblySignedName

  case class TypeName(name: TermName) extends Name

// ------ Positions ---------------------------

  case class Position(firstOffset: Int, lastOffset: Int)

  trait Positioned {
    def pos: Position = ???
  }

// ------ Statements ---------------------------------

  trait TopLevelStatement extends Positioned
  trait Statement extends TopLevelStatement

  case class Package(pkg: Term, body: List[TopLevelStatement]) extends TopLevelStatement

  case class Import(expr: Term, selector: List[ImportSelector]) extends Statement

  enum ImportSelector {
    case Simple(id: Id)
    case Rename(id1: Id, id2: Id)
    case Omit(id1: Id)
  }

  case class Id(name: String) extends Positioned     // untyped ident

// ------ Definitions ---------------------------------

  class Symbol {
    def owner: Symbol = ???
    def definition: Definition = ???
  }
  object NoSymbol extends Symbol

  trait Definition {
    def sym: Symbol = ???
  }

  case class ValDef(name: TermName, tpt: Term, rhs: Term | Empty, mods: List[Modifier]) extends Definition
  case class DefDef(name: TermName, typeParams: List[TypeDef], paramss: List[List[ValDef]],
                    returnTpt: Term, rhs: Term | Empty, mods: List[Modifier]) extends Definition
  case class TypeDef(name: TypeName, rhs: Term, mods: List[Modifier]) extends Definition
  case class ClassDef(name: TypeName, constructor: DefDef, parents: List[Term],
                      self: ValDef | Empty, body: List[Statement], mods: List[Modifier]) extends Definition

// ------ Terms ---------------------------------

  /** Trees denoting terms */
  enum Term extends Statement {
    def tpe: Type = ???
    case Ident(name: TermName, override val tpe: Type)
    case Select(prefix: Term, name: PossiblySignedName)
    case Literal(value: Constant)
    case This(id: Id | Empty)
    case New(tpt: Term)
    case NamedArg(name: TermName, arg: Term)
    case Apply(fn: Term, args: List[Term])
    case TypeApply(fn: Term, args: List[Term])
    case Super(thiz: Term, mixin: Id | Empty)
    case Typed(expr: Term, tpt: Term)
    case Assign(lhs: Term, rhs: Term)
    case Block(stats: List[Statement], expr: Term)
    case Inlined(call: Term, bindings: List[Definition], expr: Term)
    case Lambda(method: Term, tpt: Term | Empty)
    case If(cond: Term, thenPart: Term, elsePart: Term)
    case Match(scrutinee: Term, cases: List[CaseDef])
    case Try(body: Term, catches: List[CaseDef], finalizer: Term | Empty)
    case Return(expr: Term)
    case Repeated(args: List[Term])
    case SelectOuter(from: Term, levels: Int, target: Type) // can be generated by inlining
    case Tpt(underlying: TypeTerm | Empty)
  }

  /** Trees denoting types */
  enum TypeTerm extends Positioned {
    def tpe: Type = ???
    case Ident(name: TypeName, override val tpe: Type)
    case Select(prefix: Term, name: TypeName)
    case Singleton(ref: Term)
    case Refined(underlying: TypeTerm, refinements: List[Definition])
    case Applied(tycon: TypeTerm, args: List[TypeTerm])
    case TypeBounds(loBound: TypeTerm, hiBound: TypeTerm)
    case Annotated(tpt: TypeTerm, annotation: Term)
    case And(left: TypeTerm, right: TypeTerm)
    case Or(left: TypeTerm, right: TypeTerm)
    case ByName(tpt: TypeTerm)
  }

  /** Trees denoting patterns */
  enum Pattern extends Positioned {
    def tpe: Type = ???
    case Value(v: Term)
    case Bind(name: TermName, pat: Pattern)
    case Unapply(unapply: Term, implicits: List[Term], pats: List[Pattern])
    case Alternative(pats: List[Pattern])
    case TypeTest(tpt: Term)
    case Wildcard()
  }

  case class CaseDef(pat: Pattern, guard: Term | Empty, rhs: Term) extends Positioned

// ------ Types ---------------------------------

  sealed trait Type

  object Type {
    private val PlaceHolder = SymRef(NoSymbol, Empty)

    case class ConstantType(value: Constant) extends Type
    case class SymRef(sym: Symbol, qualifier: Type | Empty = Empty) extends Type
    case class NameRef(name: Name, qualifier: Type | Empty = Empty) extends Type // Empty means: select from _root_
    case class SuperType(thistp: Type, underlying: Type) extends Type
    case class Refinement(underlying: Type, name: Name, tpe: Type) extends Type
    case class AppliedType(tycon: Type, args: List[Type | TypeBounds]) extends Type
    case class AnnotatedType(underlying: Type, annotation: Term) extends Type
    case class AndType(left: Type, right: Type) extends Type
    case class OrType(left: Type, right: Type) extends Type
    case class ByNameType(underlying: Type) extends Type
    case class ParamRef(binder: LambdaType[_, _, _], idx: Int) extends Type
    case class RecursiveThis(binder: RecursiveType) extends Type

    abstract case class RecursiveType(private var _underlying: Type) extends Type {
      def underlying = _underlying
    }
    object RecursiveType {
      def apply(underlyingExp: RecursiveType => Type) = {
        val rt = new RecursiveType(PlaceHolder) {}
        rt._underlying = underlyingExp(rt)
        rt
      }
    }

    abstract class LambdaType[ParamName, ParamInfo, This <: LambdaType[ParamName, ParamInfo, This]](
      val companion: LambdaTypeCompanion[ParamName, ParamInfo, This]
    ) {
      private[Type] var _pinfos: List[ParamInfo]
      private[Type] var _restpe: Type

      def paramNames: List[ParamName]
      def paramInfos: List[ParamInfo] = _pinfos
      def resultType: Type = _restpe
    }

    abstract class LambdaTypeCompanion[ParamName, ParamInfo, This <: LambdaType[ParamName, ParamInfo, This]] {
      def apply(pnames: List[ParamName], ptypes: List[ParamInfo], restpe: Type): This

      def apply(pnames: List[ParamName], ptypesExp: This => List[ParamInfo], restpeExp: This => Type): This = {
        val lambda = apply(pnames, Nil, PlaceHolder)
        lambda._pinfos = ptypesExp(lambda)
        lambda._restpe = restpeExp(lambda)
        lambda
      }
    }

    case class MethodType(paramNames: List[TermName], private[Type] var _pinfos: List[Type], private[Type] var _restpe: Type)
    extends LambdaType[TermName, Type, MethodType](MethodType) {
      def isImplicit = (companion `eq` ImplicitMethodType) || (companion `eq` ErasedImplicitMethodType)
      def isErased = (companion `eq` ErasedMethodType) || (companion `eq` ErasedImplicitMethodType)
    }

    case class PolyType(paramNames: List[TypeName], private[Type] var _pinfos: List[TypeBounds], private[Type] var _restpe: Type)
    extends LambdaType[TypeName, TypeBounds, PolyType](PolyType)

    case class TypeLambda(paramNames: List[TypeName], private[Type] var _pinfos: List[TypeBounds], private[Type] var _restpe: Type)
    extends LambdaType[TypeName, TypeBounds, TypeLambda](TypeLambda)

    object TypeLambda extends LambdaTypeCompanion[TypeName, TypeBounds, TypeLambda]
    object PolyType   extends LambdaTypeCompanion[TypeName, TypeBounds, PolyType]
    object MethodType extends LambdaTypeCompanion[TermName, Type, MethodType]

    class SpecializedMethodTypeCompanion extends LambdaTypeCompanion[TermName, Type, MethodType] { self =>
      def apply(pnames: List[TermName], ptypes: List[Type], restpe: Type): MethodType =
        new MethodType(pnames, ptypes, restpe) { override val companion = self }
    }
    object ImplicitMethodType extends SpecializedMethodTypeCompanion
    object ErasedMethodType extends SpecializedMethodTypeCompanion
    object ErasedImplicitMethodType extends SpecializedMethodTypeCompanion

    case class TypeBounds(loBound: Type, hiBound: Type)
  }

// ------ Modifiers ---------------------------------

  enum Modifier extends Positioned {
    case Private, Protected, Abstract, Final, Sealed, Case, Implicit, Erased, Lazy, Override, Inline,
         Macro,                 // inline method containing toplevel splices
         Static,                // mapped to static Java member
         Object,                // an object or its class (used for a ValDef or a ClassDef, respectively)
         Trait,                 // a trait (used for a ClassDef)
         Local,                 // used in conjunction with Private/private[Type] to mean private[this], proctected[this]
         Synthetic,             // generated by Scala compiler
         Artifact,              // to be tagged Java Synthetic
         Mutable,               // when used on a ValDef: a var
         Label,                 // method generated as a label
         FieldAccessor,         // a getter or setter
         CaseAcessor,           // getter for case class parameter
         Covariant,             // type parameter marked “+”
         Contravariant,         // type parameter marked “-”
         Scala2X,               // Imported from Scala2.x
         DefaultParameterized,  // Method with default parameters
         Stable                 // Method that is assumed to be stable

    case QualifiedPrivate(boundary: Type)
    case QualifiedProtected(boundary: Type)
    case Annotation(tree: Term)
  }

// ------ Constants ---------------------------------

  enum Constant(value: Any) {
    case Unit                            extends Constant(())
    case False                           extends Constant(false)
    case True                            extends Constant(true)
    case Null                            extends Constant(null)
    case Byte(value: scala.Byte)         extends Constant(value)
    case Short(value: scala.Short)       extends Constant(value)
    case Char(value: scala.Char)         extends Constant(value)
    case Int(value: scala.Int)           extends Constant(value)
    case Long(value: scala.Long)         extends Constant(value)
    case Float(value: scala.Float)       extends Constant(value)
    case Double(value: scala.Double)     extends Constant(value)
    case String(value: java.lang.String) extends Constant(value)
    case Class(value: Type)              extends Constant(value)
    case Enum(value: Type)               extends Constant(value)
  }

  sealed class Empty()
  object Empty extends Empty
}

object Test {
  import tasty._
  import Type._

  def show(tp: Type) = tp match {
    case ConstantType(value) => ???
    case SymRef(sym, Empty) => ???
    case SymRef(sym, qual) => ???
    case NameRef(name: Name, qualifier) => ???
    case SuperType(thistp: Type, underlying: Type) => ???
    case Refinement(underlying: Type, name: Name, tpe: Type) => ???
    case AppliedType(tycon, args) => ???
    case AnnotatedType(underlying: Type, annotation: Term) => ???
    case AndType(left: Type, right: Type) => ???
    case OrType(left: Type, right: Type) => ???
    case ByNameType(underlying: Type) => ???
    case ParamRef(binder, idx) => ???
    case RecursiveThis(binder: RecursiveType) => ???
    case RecursiveType(tp) => ???
    case MethodType(pnames, ptypes, resType) => ???
    case PolyType(pnames, ptypes, resType) => ???
    case TypeLambda(pnames, ptypes, resType) => ???
  }
}